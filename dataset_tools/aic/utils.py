import openpyxl as pyxl
import numpy as np
import math
import os
from collections import OrderedDict
import random


def parseXLSX(xlsxName, parsed_output):
    """
    :param xlsxName: .xlsx files holding the ground truth
    :param parsed_output: an numpy array containing the parsed ground truth
    :return: the input parsed_output will be changed inplace
    """
    workbook = pyxl.load_workbook(xlsxName)
    sheetnames = workbook.sheetnames
    worksheet = workbook[sheetnames[0]]  # get the first work sheet
    # content in the work sheet per row: "video_name frame_id movement_id vehicle_class_id"
    for i in range(2, worksheet.max_row + 1):
        temp = worksheet.cell(row=i, column=2).value
        frame_id = int(temp)

        temp = worksheet.cell(row=i, column=3).value
        movement_id = int(temp)

        temp = worksheet.cell(row=i, column=4).value.strip(' ')
        if temp == 'car':
            vehicle_type = 0
        else:
            vehicle_type = 1  # for the truck

        parsed_output[frame_id, movement_id - 1, vehicle_type] = 1


def parseTXT(txtName, parsed_output):
    """
    :param txtName: .txt files holding predicted counting results
    :param parsed_output: an numpy array containing the predicted results to be used for nwRMSE calculation
    :return: the input parsed_output will be changed inplace
    """
    with open(txtName, 'r') as fp:
        lines = fp.readlines()

    for line in lines:
        row_content = line.strip('\n').split(' ')
        frame_id = int(row_content[1]) - 1  # the ids start from 1
        if frame_id >= 3000:  # the ground truth only has the ground truth counts for at most 3000 frames
            continue

        movement_id = int(row_content[2]) - 1
        vehicle_type = int(row_content[3]) - 1

        parsed_output[frame_id, movement_id, vehicle_type] = 1


def compute_nwRMSE(num_segment, pred_counts, gt_counts):
    """
    :param num_segment: total number of segments of each video, to calculate the weights for wRMSE
    :param pred_counts: an array of shape: (num_frame, num_movement, num_vechile_type)
    :param gt_counts: an array of shape: (num_frame, num_movement, num_vechile_type)
    :return: nwRMSE for each video normalized by the counts of each movement and each vehicle type
    """
    wRMSE_weights = np.asarray(np.arange(1, num_segment + 1)) * 2. / (num_segment * (num_segment + 1))
    num_frame, num_movement, num_type = pred_counts.shape
    frame_list = range(0, num_frame)
    interval = int(math.ceil(num_frame * 1. / num_segment))
    segments = [frame_list[i:i + interval] for i in range(0, len(frame_list), interval)]

    # gtCnt = np.zeros(num_movement)  # counts per MOI
    # predCnt = np.zeros(num_movement)
    nwRMSE_result = np.zeros((num_movement, num_type))  # score per MOI per vehicle type
    wRMSE_result = np.zeros((num_movement, num_type))
    vehicleCnt = np.zeros((num_movement, num_type))  # Total gt counts

    for movement_id in range(0, num_movement):
        # gtCnt[movement_id] = np.sum(gt_counts[:, movement_id, :])  # total counts for all vehicles in all frames
        # predCnt[movement_id] = np.sum(pred_counts[:, movement_id, :])
        for vehicle_type in range(0, num_type):
            # calcualte wRMSE
            cumError = np.zeros(num_segment)
            for segId, frames in enumerate(segments):
                mse = (np.sum(pred_counts[0:frames[-1] + 1, movement_id, vehicle_type]) -
                       np.sum(gt_counts[0:frames[-1] + 1, movement_id, vehicle_type])) ** 2.
                cumError[segId] = mse

            wRMSE = np.sqrt(np.dot(wRMSE_weights, cumError))
            vehicleCnt[movement_id, vehicle_type] = np.sum(gt_counts[:, movement_id, vehicle_type])

            if vehicleCnt[movement_id, vehicle_type] != 0 and wRMSE < vehicleCnt[movement_id, vehicle_type]:
                wRMSE_result[movement_id, vehicle_type] = wRMSE / vehicleCnt[movement_id, vehicle_type]
                nwRMSE_result[movement_id, vehicle_type] = 1. - wRMSE_result[movement_id, vehicle_type]

    return nwRMSE_result, vehicleCnt  # these are the raw scores and counts


def compute_efficiency_score(execution_time, video_time, base_factor):
    """
    :param execution_time: list of execution time, one for each video
    :param video_time: list of total video play time, one for each video, should have the same length
    :param base_factor: result generated by running "python efficiency_base.py"
    :return: efficiency score
    """
    # assert len(execution_time) == len(video_time)
    time_ = np.sum(execution_time)
    video_time_ = np.sum(video_time)
    score = max(0., 1. - (time_ * base_factor / (1.1 * video_time_)))
    return score


def add_hit_to_counts(pred_counts, gt_counts, num_hit=1, sample='random'):
    """
    :param pred_counts:
    :param gt_counts:
    :param num_hit: number of hit(perturbation of predicted counts) to be added
    :param sample:
    :return: pred_counts will be changed inplace
    """
    assert pred_counts.shape == gt_counts.shape and num_hit >= 0
    if num_hit == 0:
        return pred_counts

    num_cars = np.sum(gt_counts[:, :, 0] == 1)
    num_trucks = np.sum(gt_counts[:, :, 1] == 1)
    tau = num_cars / (num_cars + num_trucks + 1e-6)

    for _ in range(num_hit):
        r = random.uniform(0, 1)
        if r > tau:
            type_to_add = 1
        else:
            type_to_add = 0

        # select a frame to add
        candidate_idx = np.where((pred_counts[:, :, type_to_add] == 0) & (gt_counts[:, :, type_to_add] == 0))
        idx = random.randint(0, len(candidate_idx[0]) - 1)
        frame_id = candidate_idx[0][idx]
        movement_id = candidate_idx[1][idx]

        assert pred_counts[frame_id, movement_id, type_to_add] == 0
        pred_counts[frame_id, movement_id, type_to_add] = 1

    return


def remove_hit_to_counts(pred_counts, gt_counts, num_hit=1, sample='random'):
    """
    :param pred_counts:
    :param gt_counts:
    :param num_hit: number of hit(perturbation of predicted counts) to be added
    :param sample:
    :return: pred_counts will be changed inplace
    """
    assert pred_counts.shape == gt_counts.shape and num_hit >= 0
    if num_hit == 0:
        return

    diff_counts = gt_counts - pred_counts  # 1 is false negatives, and -1 is false positives
    # missed_cars = np.sum(diff_counts[:, :, 0] < 0)
    # missed_trucks = np.sum(diff_counts[:, :, 1] < 0)
    # tau = missed_cars / (missed_cars + missed_trucks + 1e-6)  # a threshold determining whether to add a car or a truck
    num_cars = np.sum(gt_counts[:, :, 0] == 1)
    num_trucks = np.sum(gt_counts[:, :, 1] == 1)
    missed_cars = np.sum(diff_counts[:, :, 0] > 0)
    missed_trucks = np.sum(diff_counts[:, :, 1] > 0)
    tau_car = (num_cars - missed_cars) / (missed_cars + 1e-6)  # a threshold determining whether to add a car or a truck
    tau_truck = (num_trucks - missed_trucks) / (missed_trucks + 1e-6)
    tau = tau_car / (tau_truck + tau_car)

    for _ in range(num_hit):
        r = random.uniform(0, 1)
        if r > tau:
            type_to_remove = 1
        else:
            type_to_remove = 0
        # select a frame to add
        candidate_idx = np.where((pred_counts[:, :, type_to_remove] == 1) & (gt_counts[:, :, type_to_remove] == 1))
        idx = random.randint(0, len(candidate_idx[0]) - 1)
        frame_id = candidate_idx[0][idx]
        movement_id = candidate_idx[1][idx]
        # print(frame_id, movement_id)

        assert pred_counts[frame_id, movement_id, type_to_remove] == 1
        pred_counts[frame_id, movement_id, type_to_remove] = 0

    return
